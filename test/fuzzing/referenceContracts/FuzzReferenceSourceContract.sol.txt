// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import "./helper/preconditions/PreconditionsEpochLiquidityModule.sol";
import "./helper/postconditions/PostconditionsEpochLiquidityModule.sol";
import "./util/FunctionCalls.sol";

import {SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
import {SafeCastU256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";

contract FuzzEpochLiquidityModule is PreconditionsEpochLiquidityModule, PostconditionsEpochLiquidityModule {
    using SafeCastI256 for int256;
    using SafeCastU256 for uint256;

    function fuzz_createLiquidityPosition(uint256 collateralAmountSeed, int24 lowerTickSeed, int24 upperTickSeed)
        public
        setCurrentActor(false)
    {
        createLPPostParams memory postParams;

        postParams.market = vault1Active ? address(vault.market()) : address(vault2.market());

        IFoilStructs.LiquidityMintParams memory params =
            createLiquidityPositionPreconditions(collateralAmountSeed, lowerTickSeed, upperTickSeed, postParams.market);

        postParams.actorsToUpdate = new address[](1);
        postParams.actorsToUpdate[0] = currentActor;

        _before(postParams.actorsToUpdate, postParams.market);

        (postParams.success, postParams.returnData) = _createLiquidityPositionCall(postParams.market, params);

        (postParams.positionId,,, postParams.liquidity, postParams.amountTokenA, postParams.amountTokenB) =
            abi.decode(postParams.returnData, (uint256, uint256, uint256, uint128, uint256, uint256));

        if (postParams.success) {
            addPosition(postParams.market, params.epochId, currentActor, postParams.positionId, true, false);
            createLPCount += 1;
        }

        createLiquidityPositionPostconditions(postParams);
    }

    function fuzz_createLiquidityPositionMultiple(
        uint256 collateralAmountSeed,
        int24 lowerTickSeed,
        int24 upperTickSeed
    ) internal {
        createLPPostParams memory postParams;

        for (uint256 i; i < 5; i++) {
            currentActor = USERS[fl.clamp(collateralAmountSeed + i, 0, USERS.length - 1)];

            postParams.market = vault1Active ? address(vault.market()) : address(vault2.market());

            IFoilStructs.LiquidityMintParams memory params = createLiquidityPositionPreconditions(
                collateralAmountSeed, lowerTickSeed, upperTickSeed, postParams.market
            );

            postParams.actorsToUpdate = new address[](1);
            postParams.actorsToUpdate[0] = currentActor;

            _before(postParams.actorsToUpdate, postParams.market);

            (postParams.success, postParams.returnData) = _createLiquidityPositionCall(postParams.market, params);

            (postParams.positionId,,, postParams.liquidity, postParams.amountTokenA, postParams.amountTokenB) =
                abi.decode(postParams.returnData, (uint256, uint256, uint256, uint128, uint256, uint256));

            if (postParams.success) {
                addPosition(postParams.market, params.epochId, currentActor, postParams.positionId, true, false);
                createLPCount += 1;
            }

            createLiquidityPositionPostconditions(postParams);
        }
    }

    // function fuzz_createLiquidityPosition_feeCollector(
    //     uint collateralAmountSeed,
    //     int24 lowerTickSeed,
    //     int24 upperTickSeed
    // ) public setCurrentActor(true) {

    //     createLPPostParams memory postParams;

    //     postParams.market = vault1Active ? address(vault.market()) : address(vault2.market());

    //     IFoilStructs.LiquidityMintParams
    //         memory params = createLiquidityPositionPreconditions(
    //             collateralAmountSeed,
    //             lowerTickSeed,
    //             upperTickSeed,
    //             postParams.market
    //         );

    //     params.collateralAmount = 0;

    //     postParams.actorsToUpdate = new address[](1);
    //     postParams.actorsToUpdate[0] = currentActor;

    //     _before(postParams.actorsToUpdate, postParams.market);

    //     (postParams.success, postParams.returnData) = _createLiquidityPositionCall(
    //         postParams.market,
    //         params
    //     );

    //     (postParams.positionId, , , postParams.liquidity, postParams.amountTokenA, postParams.amountTokenB) = abi.decode(
    //         postParams.returnData,
    //         (uint, uint, uint, uint128, uint, uint)
    //     );

    //     if (postParams.success) {
    //         addPositionFeeCollector(postParams.market, params.epochId, currentActor, postParams.positionId, true, false);
    //     }

    //     createLiquidityPositionPostconditions(
    //         postParams
    //     );

    // }

    function fuzz_increaseLiquidityPosition(uint256 collateralAmountSeed) public setCurrentActor(false) {
        weth.balanceOf(foil); //resetting prank

        address market = vault1Active ? address(vault.market()) : address(vault2.market());

        IFoilStructs.LiquidityIncreaseParams memory params =
            increaseLiquidityPositionPreconditions(collateralAmountSeed, market);

        (IFoilStructs.EpochData memory epochData,) = IFoil(market).getEpoch(getLatestEpoch(market));
        if (epochData.settled || block.timestamp >= epochData.endTime) return;

        address[] memory actorsToUpdate = new address[](1);
        actorsToUpdate[0] = currentActor;

        _before(actorsToUpdate, market);
        (bool success, bytes memory returnData) = _increaseLiquidityPositionCall(market, params);

        increaseLiquidityPositionPostConditions(success, returnData, actorsToUpdate, market);
    }

    function fuzz_increaseLiquidityPositionMultiple(uint256 collateralAmountSeed) internal {
        for (uint256 i; i < 10; i++) {
            currentActor = USERS[fl.clamp(collateralAmountSeed + i, 0, USERS.length - 1)];

            address market = vault1Active ? address(vault.market()) : address(vault2.market());

            IFoilStructs.LiquidityIncreaseParams memory params =
                increaseLiquidityPositionPreconditions(collateralAmountSeed + i, market);

            (IFoilStructs.EpochData memory epochData,) = IFoil(market).getEpoch(getLatestEpoch(market));
            if (epochData.settled || block.timestamp >= epochData.endTime) return;

            address[] memory actorsToUpdate = new address[](1);
            actorsToUpdate[0] = currentActor;

            _before(actorsToUpdate, market);
            (bool success, bytes memory returnData) = _increaseLiquidityPositionCall(market, params);

            increaseLiquidityPositionPostConditions(success, returnData, actorsToUpdate, market);
        }
    }

    // function fuzz_increaseLiquidityPosition_feeCollector(
    //     uint collateralAmountSeed
    // ) public setCurrentActor(true) {
    //     weth.balanceOf(foil); //resetting prank

    //     address market = vault1Active ? address(vault.market()) : address(vault2.market());

    //     IFoilStructs.LiquidityIncreaseParams
    //         memory params = increaseLiquidityPositionPreconditionsFeeCollector(
    //             collateralAmountSeed,
    //             market
    //         );

    //     (IFoilStructs.EpochData memory epochData, ) = IFoil(market).getEpoch(getLatestEpoch(market));
    //     if (epochData.settled || block.timestamp >= epochData.endTime) return;

    //     address[] memory actorsToUpdate = new address[](1);
    //     actorsToUpdate[0] = currentActor;

    //     _before(actorsToUpdate, market);
    //     (
    //         bool success,
    //         bytes memory returnData
    //     ) = _increaseLiquidityPositionCall(market, params);

    //     increaseLiquidityPositionPostConditions(
    //         success,
    //         returnData,
    //         actorsToUpdate,
    //         market
    //     );
    // }

    function fuzz_decreaseLiquidityPosition(uint256 seed) public setCurrentActor(false) {
        address market = vault1Active ? address(vault.market()) : address(vault2.market());

        IFoilStructs.LiquidityDecreaseParams memory params = decreaseLiquidityPositionPreconditions(seed, market);

        (IFoilStructs.EpochData memory epochData,) = IFoil(market).getEpoch(getLatestEpoch(market));
        if (epochData.settled || block.timestamp >= epochData.endTime) return;

        address[] memory actorsToUpdate = new address[](1);
        actorsToUpdate[0] = currentActor;
        uint256 stateChangerVar = 30 * 30; //@audit fuzzing cov trick to cover function with optimizer
        _before(actorsToUpdate, market);
        (bool success, bytes memory returnData) = _decreaseLiquidityPositionCall(market, params);
        stateChangerVar = 30 * 38;

        if (success) {
            if (isPositionTypeTrade(market, params.positionId)) {
                deletePosition(
                    market,
                    getLatestEpoch(market),
                    currentActor,
                    params.positionId,
                    true //isLiquidity
                );
                addPosition(
                    market,
                    getLatestEpoch(market),
                    currentActor,
                    params.positionId,
                    false, //isLiquidity, its a trade position
                    true
                );
            }
        }

        decreaseLiquidityPositionPostConditions(
            success, returnData, actorsToUpdate, params.positionId, params.liquidity, market
        );
        stateChangerVar = 4 * 38;
    }

    function fuzz_decreaseLiquidityPositionMultiple(uint256 seed) internal {
        for (uint256 i; i < 10; i++) {
            currentActor = USERS[fl.clamp(seed + i, 0, USERS.length - 1)];

            address market = vault1Active ? address(vault.market()) : address(vault2.market());

            IFoilStructs.LiquidityDecreaseParams memory params =
                decreaseLiquidityPositionPreconditions(seed + i, market);

            (IFoilStructs.EpochData memory epochData,) = IFoil(market).getEpoch(getLatestEpoch(market));
            if (epochData.settled || block.timestamp >= epochData.endTime) return;

            address[] memory actorsToUpdate = new address[](1);
            actorsToUpdate[0] = currentActor;
            uint256 stateChangerVar = 30 * 30; //@audit fuzzing cov trick to cover function with optimizer
            _before(actorsToUpdate, market);
            (bool success, bytes memory returnData) = _decreaseLiquidityPositionCall(market, params);
            stateChangerVar = 30 * 38;

            if (success) {
                if (isPositionTypeTrade(market, params.positionId)) {
                    deletePosition(
                        market,
                        getLatestEpoch(market),
                        currentActor,
                        params.positionId,
                        true //isLiquidity
                    );
                    addPosition(
                        market,
                        getLatestEpoch(market),
                        currentActor,
                        params.positionId,
                        false, //isLiquidity, its a trade position
                        true
                    );
                }
            }

            decreaseLiquidityPositionPostConditions(
                success, returnData, actorsToUpdate, params.positionId, params.liquidity, market
            );
            stateChangerVar = 4 * 38;
        }
    }

    // function fuzz_decreaseLiquidityPosition_feeCollector(uint seed) public setCurrentActor(true) {

    //     address market = vault1Active ? address(vault.market()) : address(vault2.market());

    //     IFoilStructs.LiquidityDecreaseParams
    //         memory params = decreaseLiquidityPositionPreconditionsFeeCollector(seed, market);

    //     (IFoilStructs.EpochData memory epochData, ) = IFoil(market).getEpoch(getLatestEpoch(market));
    //     if (epochData.settled || block.timestamp >= epochData.endTime) return;

    //     address[] memory actorsToUpdate = new address[](1);
    //     actorsToUpdate[0] = currentActor;
    //     uint stateChangerVar = 30 * 30; //@audit fuzzing cov trick to cover function with optimizer
    //     _before(actorsToUpdate, market);
    //     (
    //         bool success,
    //         bytes memory returnData
    //     ) = _decreaseLiquidityPositionCall(market, params);

    //     stateChangerVar = 30 * 38;

    //     if (success) {
    //         if (isPositionTypeTrade(market, params.positionId)) {
    //             deletePositionFeeCollector(
    //                 market,
    //                 getLatestEpoch(market),
    //                 currentActor,
    //                 params.positionId,
    //                 true //isLiquidity
    //             );
    //             addPositionFeeCollector(
    //                 market,
    //                 getLatestEpoch(market),
    //                 currentActor,
    //                 params.positionId,
    //                 false, //isLiquidity, its a trade position
    //                 true
    //             );
    //         }
    //     }

    //     decreaseLiquidityPositionPostConditions(
    //         success,
    //         returnData,
    //         actorsToUpdate,
    //         params.positionId,
    //         params.liquidity,
    //         market
    //     );
    //     stateChangerVar = 4 * 38;

    // }

    function fuzz_closeLiquidityPosition(uint256 seed) public setCurrentActor(false) {
        address market = vault1Active ? address(vault.market()) : address(vault2.market());

        IFoilStructs.LiquidityDecreaseParams memory params = closeLiquidityPositionPreconditions(seed, market); //close is a branch in decrease

        (IFoilStructs.EpochData memory epochData,) = IFoil(market).getEpoch(getLatestEpoch(market));
        if (epochData.settled || block.timestamp >= epochData.endTime) return;

        address[] memory actorsToUpdate = new address[](1);
        actorsToUpdate[0] = currentActor;

        _before(actorsToUpdate, market);
        (bool success, bytes memory returnData) = _decreaseLiquidityPositionCall(market, params);

        if (success) {
            if (isPositionTypeTrade(market, params.positionId)) {
                deletePosition(
                    market,
                    getLatestEpoch(market),
                    currentActor,
                    params.positionId,
                    true //isLiquidity
                );
                addPosition(
                    market,
                    getLatestEpoch(market),
                    currentActor,
                    params.positionId,
                    false, //isLiquidity, its a trade position
                    true
                );
            }
        }

        closeLiquidityPositionPostConditions(
            success, returnData, actorsToUpdate, isPositionTypeTrade(market, params.positionId), params, market
        );
    }

    function fuzz_open_close_liquidityPosition(
        uint256 seed,
        uint256 collateralAmountSeed,
        int24 lowerTickSeed,
        int24 upperTickSeed
    ) public setCurrentActor(false) {
        uint256 balanceInitial = wstETH.balanceOf(currentActor);
        createLPPostParams memory postParams;

        postParams.market = vault1Active ? address(vault.market()) : address(vault2.market());

        IFoilStructs.LiquidityMintParams memory params =
            createLiquidityPositionPreconditions(collateralAmountSeed, lowerTickSeed, upperTickSeed, postParams.market);

        postParams.actorsToUpdate = new address[](1);
        postParams.actorsToUpdate[0] = currentActor;

        _before(postParams.actorsToUpdate, postParams.market);

        (postParams.success, postParams.returnData) = _createLiquidityPositionCall(postParams.market, params);

        (postParams.positionId,,, postParams.liquidity, postParams.amountTokenA, postParams.amountTokenB) =
            abi.decode(postParams.returnData, (uint256, uint256, uint256, uint128, uint256, uint256));

        if (postParams.success) {
            addPosition(postParams.market, params.epochId, currentActor, postParams.positionId, true, false);
            createLPCount += 1;
        }

        address market = postParams.market;

        IFoilStructs.LiquidityDecreaseParams memory decreaseParams =
            closeLiquidityPositionPreconditionsWithId(seed, market, postParams.positionId); //close is a branch in decrease

        (IFoilStructs.EpochData memory epochData,) = IFoil(market).getEpoch(getLatestEpoch(market));
        if (epochData.settled || block.timestamp >= epochData.endTime) return;

        address[] memory actorsToUpdate = new address[](1);
        actorsToUpdate[0] = currentActor;

        _before(actorsToUpdate, market);
        (bool success, bytes memory returnData) = _decreaseLiquidityPositionCall(market, decreaseParams);

        if (success) {
            if (isPositionTypeTrade(market, decreaseParams.positionId)) {
                deletePosition(
                    market,
                    getLatestEpoch(market),
                    currentActor,
                    decreaseParams.positionId,
                    true //isLiquidity
                );
                addPosition(
                    market,
                    getLatestEpoch(market),
                    currentActor,
                    decreaseParams.positionId,
                    false, //isLiquidity, its a trade position
                    true
                );
            }
            // if (success && postParams.success) {
            //     fl.t(false, "SUCCESS FOR OPEN CLOSE");
            // }
        }

        closeLiquidityPositionPostConditions(
            success,
            returnData,
            actorsToUpdate,
            isPositionTypeTrade(market, decreaseParams.positionId),
            decreaseParams,
            market
        );
        uint256 balanceFinal = wstETH.balanceOf(currentActor);
        fl.t(balanceFinal <= balanceInitial, "open then close LP balance after should be less than or equal to before");
        assertApproxEqAbs(
            balanceFinal, balanceInitial, 1e2, "open then close LP user's balance should remain the same!"
        );
    }

    // function fuzz_closeLiquidityPosition_feeCollector(uint seed) public setCurrentActor(true) {

    //     address market = vault1Active ? address(vault.market()) : address(vault2.market());

    //     IFoilStructs.LiquidityDecreaseParams
    //         memory params = closeLiquidityPositionPreconditionsFeeCollector(seed, market); //close is a branch in decrease

    //     (IFoilStructs.EpochData memory epochData, ) = IFoil(market).getEpoch(getLatestEpoch(market));
    //     if (epochData.settled || block.timestamp >= epochData.endTime) return;

    //     address[] memory actorsToUpdate = new address[](1);
    //     actorsToUpdate[0] = currentActor;

    //     _before(actorsToUpdate, market);
    //     (
    //         bool success,
    //         bytes memory returnData
    //     ) = _decreaseLiquidityPositionCall(market, params);

    //     if (success) {
    //         if (isPositionTypeTrade(market, params.positionId)) {
    //             deletePositionFeeCollector(
    //                 market,
    //                 getLatestEpoch(market),
    //                 currentActor,
    //                 params.positionId,
    //                 true //isLiquidity
    //             );
    //             addPositionFeeCollector(
    //                 market,
    //                 getLatestEpoch(market),
    //                 currentActor,
    //                 params.positionId,
    //                 false, //isLiquidity, its a trade position
    //                 true
    //             );
    //         }
    //     }

    //     closeLiquidityPositionPostConditions(
    //             success,
    //             returnData,
    //             actorsToUpdate,
    //             isPositionTypeTrade(market, params.positionId),
    //             params,
    //             market
    //         );
    // }

    struct closeLPParams {
        address market;
        bool success;
        bytes returnData;
    }

    function fuzz_closeAllLiquidityPositions(uint256 marketSeed) public {
        closeLPParams memory closeParams;
        closeParams.market = vault1Active ? address(vault.market()) : address(vault2.market());

        (closeParams.success, closeParams.returnData) = _getLatestEpochCall(closeParams.market);
        if (closeParams.success) {
            //epoch should be created
            (IFoilStructs.EpochData memory epochData, IFoilStructs.MarketParams memory marketParams) =
                abi.decode(closeParams.returnData, (IFoilStructs.EpochData, IFoilStructs.MarketParams));

            if (epochData.settled || block.timestamp >= epochData.endTime) return;

            uint256 epochId = epochData.epochId;

            (PositionGhost[] memory liquidityPositions,) = getAllPositionsIdsOfAllUsers(closeParams.market, epochId);

            IFoilStructs.LiquidityDecreaseParams[] memory paramsArray =
                closeAllLiquidityPositionsPreconditions(liquidityPositions, closeParams.market);

            for (uint256 i = 0; i < paramsArray.length; i++) {
                IFoilStructs.LiquidityDecreaseParams memory params = paramsArray[i];

                (closeParams.success, closeParams.returnData) =
                    _getPositionOwnerCall(closeParams.market, params.positionId);
                assert(closeParams.success);

                address positionOwner = abi.decode(closeParams.returnData, (address));

                address[] memory actorsToUpdate = new address[](1);
                actorsToUpdate[0] = positionOwner;

                _before(actorsToUpdate, closeParams.market);

                vm.prank(positionOwner);
                (closeParams.success, closeParams.returnData) =
                    _decreaseLiquidityPositionCallNOPRANK(closeParams.market, params);

                if (closeParams.success) {
                    if (isPositionTypeTrade(closeParams.market, params.positionId)) {
                        console.log(
                            "fuzz_closeAllLiquidityPositions::This position number was converted to trade position",
                            params.positionId
                        );
                        deletePosition(
                            closeParams.market,
                            getLatestEpoch(closeParams.market),
                            positionOwner,
                            params.positionId,
                            true //isLiquidity
                        );
                        addPosition(
                            closeParams.market,
                            getLatestEpoch(closeParams.market),
                            positionOwner,
                            params.positionId,
                            false, //isLiquidity, its a trade position
                            true
                        );
                    }
                    closeLPCount += 1;
                } else {
                    if (bytes4(closeParams.returnData) != bytes4(Errors.ExpiredEpoch.selector)) {
                        fl.t(closeParams.success, SETTLE_01);
                    }
                }
                closeLiquidityPositionPostConditions(
                    closeParams.success,
                    closeParams.returnData,
                    actorsToUpdate,
                    isPositionTypeTrade(closeParams.market, params.positionId),
                    params,
                    closeParams.market
                );
            }
        }
    }

    function fuzz_depositCollateral(uint256 collateralAmountSeed) public setCurrentActor(true) {
        address market = vault1Active ? address(vault.market()) : address(vault2.market());

        DepositCollateralParams memory params = depositCollateralPreconditions(collateralAmountSeed, market);

        Position.Data memory positionBefore = IFoil(market).getPosition(params.positionId);

        address[] memory actorsToUpdate = new address[](1);
        actorsToUpdate[0] = currentActor;

        _before(actorsToUpdate, market);
        (bool success, bytes memory returnData) = _depositCollateralCall(market, params);

        Position.Data memory positionAfter = IFoil(market).getPosition(params.positionId);

        invariant_LIQUID_11(
            positionBefore.depositedCollateralAmount, positionAfter.depositedCollateralAmount, params.collateralAmount
        );
    }
}
